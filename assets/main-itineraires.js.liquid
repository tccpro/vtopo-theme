/**
 * @class metaoobject_table custom element
*/
class MetaobjectTable extends HTMLElement {

    constructor() {

        super();

        /**
        * Dom elements
        */
        this.table                  = this.querySelector('.metaobject-table');
        this.tbody                  = this.table.querySelector('TBODY');
        this.filterBox              = this.querySelector('.metaobject-filter');
        this.sortSelect             = this.querySelector('.metaobject-sort-select');
        this.totalCount             = this.querySelector('.total-count-box span.total-count');
        this.searchInput            = this.querySelector('.metaobject-search-input');
        this.drawBackLayout         = this.querySelector('.draw-back-layout');
        this.drawOpenButton         = this.querySelector('.collection-filter');
        this.drawCloseButton        = this.querySelector('.drawer__close button.drawer__close-button');
        this.activatedTagsBox       = this.querySelector('.tag-list--active-tags');
        this.paginationButtonBox    = this.querySelector('.pagination-buttons');

        /**
        * CONSTANTS
        */
        this.TYPE_SORT                  = "SORT";
        this.TYPE_RANGE                 = "RANGE";
        this.TYPE_CHECKBOX              = "CHECKBOX";
        this.TYPE_TIME_RANGE            = "TIME_RANGE";
        this.TYPE_RANGE_CHECKBOX        = "RANGE_CHECKBOX";
        
        this.ACTION_ADD                 = "ACTION_ADD";
        this.ACTION_REMOVE              = "ACTION_REMOVE";
        
        this.CONDITION_SORT             = "CONDITION_SORT";
        this.CONDITION_RANGE            = "CONDITION_RANGE";
        this.CONDITION_SEARCH           = "CONDITION_SEARCH";
        this.CONDITION_CHECKBOX         = "CONDITION_CHECKBOX";
        this.CONDITION_RANGE_CHECKBOX   = "CONDITION_RANGE_CHECKBOX";
        
        this.SORT_TITRE_ASC             = "TITRE_ASC";
        this.SORT_TITRE_DES             = "TITRE_DES";
        this.SORT_DUREE_ASC             = "DUREE_ASC";
        this.SORT_DUREE_DES             = "DUREE_DES";
        this.SORT_DISTANCE_ASC          = "DISTANCE_ASC";
        this.SORT_DISTANCE_DES          = "DISTANCE_DES";
        this.SORT_DIFFICULTE_ASC        = "DIFFICULTE_ASC";
        this.SORT_DIFFICULTE_DES        = "DIFFICULTE_DES";
        this.SORT_DEPARTEMENT_ASC       = "DEPARTEMENT_ASC";
        this.SORT_DEPARTEMENT_DES       = "DEPARTEMENT_DES";
        
        this.SORT_INDEX                 = 0;
        this.SEPERATOR                  = '_#_';
        this.REG_EX                     = /(<([^>]+)>)/gmi;
        this.REG_EX_LABEL               = /(<([^>]+)>.*<\/([^>]+))>/gmi;

        /**
        * Main data
        */
       this.CONDITIONS = new Map();
       this.TEMP_OPTIONS = new Set();
       this.SELECT_OPTIONS = new Set();
       this.DATA = window.metaobjectsForAppPage;
       this.TEMP_DATA = this.DATA; //pagination;

        /**
        * Array of header Index for filter bar
        */
        this.FILTERS = [10, 11, 1, 7, 3, 4, 6, 8];

        /**
         * Array of sort Index
         */
        this.SORTS = {
            "TITRE_ASC": 0,
            "TITRE_DES": 0,
            "DUREE_ASC": 6,
            "DUREE_DES": 6,
            "DISTANCE_ASC": 3,
            "DISTANCE_DES": 3,
            "DIFFICULTE_ASC": 2,
            "DIFFICULTE_DES": 2,
            "DEPARTEMENT_ASC": 1,
            "DEPARTEMENT_DES": 1
        }

        /**
         * Diff array for sorting
         */
        this.DIFFICULTE_NUMBER_ARRAY = {
            "V1-":  0,
            "V1":   1,
            "V1+":  2,

            "V2-":  3,
            "V2":   4,
            "V2+":  5,

            "V3-":  6,
            "V3":   7,
            "V3+":  8,

            "V4-":  9,
            "V4":   10,
            "V4+":  11,

            "V5-":  12,
            "V5":   13,
            "V5+":  14,

            "V6-":  15,
            "V6":   16,
            "V6+":  17
        }

        /**
        * Header Data
        */
        this.HEADER = [
            {
                index: 0,
                type: this.TYPE_SORT,
                visible: true,
                label: "Titre",
                maxLength: 15
            },
            {
                index: 1,
                type: this.TYPE_CHECKBOX,
                visible: true,
                label: "Département",
                maxLength: 15
            },
            {
                index: 2,
                type: this.TYPE_CHECKBOX,
                visible: true,
                label: "Diff"
            },
            {
                index: 3,
                type: this.TYPE_RANGE_CHECKBOX,
                visible: true,
                label: "Distance",
                unit: "km",
                step: 0.1,
                blockSize: 10,
                blocks: [
                    {
                        label: "Jusqu’à 10 km",
                        min: 0,
                        max: 10
                    },
                    {
                        label: "10 à 20 km",
                        min: 10,
                        max: 20
                    },
                    {
                        label: "20 à 30 km",
                        min: 20,
                        max: 30
                    },
                    {
                        label: "30 à 40 km",
                        min: 30,
                        max: 40
                    },
                    {
                        label: "À partir de 40 km",
                        min: 40,
                        max: Infinity
                    }
                ]
            },
            {
                index: 4,
                type: this.TYPE_RANGE_CHECKBOX,
                visible: true,
                label: "Dénivelée +",
                unit: "m",
                step: 0.1,
                blockSize: 300,
                blocks: [
                    {
                        label: "Jusqu’à 300m",
                        min: 0,
                        max: 300
                    },
                    {
                        label: "300 à 600m",
                        min: 300,
                        max: 600
                    },
                    {
                        label: "600 à 900m",
                        min: 600,
                        max: 900
                    },
                    {
                        label: "900 à 1200m",
                        min: 900,
                        max: 1200
                    },
                    {
                        label: "À partir de 1200m",
                        min: 1200,
                        max: Infinity
                    }
                ]
            },
            {
                index: 5,
                type: this.TYPE_SORT,
                visible: true,
                label: "D-"
            },
            {
                index: 6,
                type: this.TYPE_RANGE_CHECKBOX,
                visible: true,
                label: "Durée",
                time_formatting: true,
                unit: '',
                step: 1,
                blockSize: 60,
                blocks: [
                    {
                        label: "Jusqu’à 1h",
                        min: 0,
                        max: 60
                    }, 
                    {
                        label: "1 à 2h",
                        min: 60,
                        max: 120
                    },
                    {
                        label: "2 à 3h",
                        min: 120,
                        max: 180
                    },
                    {
                        label: "3 à 4h",
                        min: 180,
                        max: 240
                    },
                    {
                        label: "À partir de 4h",
                        min: 240,
                        max: Infinity
                    }
                ]
            },
            {
                index: 7,
                type: this.TYPE_CHECKBOX,
                visible: false,
                label: "Niveau"
            },
            {
                index: 8,
                type: this.TYPE_CHECKBOX,
                visible: false,
                label: "Profil",
                isArray: true
            },
            {
                index: 9,
                type: this.TYPE_CHECKBOX,
                visible: false,
                label: "Discipline"
            },
            {
                index: 10,
                type: this.TYPE_CHECKBOX,
                visible: false,
                label: "Pays"
            },
            {
                index: 11,
                type: this.TYPE_CHECKBOX,
                visible: false,
                label: "Region"
            }
        ];

        /**
        * Pagination
        */
        this.ROWS_PER_PAGINATION = 30;
        this.CURRENT_PAGE_INDEX = 0;
        this.PAGE_TOTAL = 0;
        this.PREV_BUTTON_ICON = `<svg aria-hidden="true" focusable="false" role="presentation" class="icon icon-chevron-left" viewBox="0 0 284.49 498.98"><path d="M249.49 0a35 35 0 0 1 24.75 59.75L84.49 249.49l189.75 189.74a35.002 35.002 0 1 1-49.5 49.5L10.25 274.24a35 35 0 0 1 0-49.5L224.74 10.25A34.89 34.89 0 0 1 249.49 0z"></path></svg>`;
        this.NEXT_BUTTON_ICON = `<svg aria-hidden="true" focusable="false" role="presentation" class="icon icon-chevron-right" viewBox="0 0 284.49 498.98"><path d="M35 498.98a35 35 0 0 1-24.75-59.75l189.74-189.74L10.25 59.75a35.002 35.002 0 0 1 49.5-49.5l214.49 214.49a35 35 0 0 1 0 49.5L59.75 488.73A34.89 34.89 0 0 1 35 498.98z"></path></svg>`;
        this.DOTS_CONTENT = '…';

        /**
        * Search and sort event handler bind
        */
        this.searchInput.addEventListener('input', this.search.bind(this));
        this.sortSelect.addEventListener('change', this.sort.bind(this));

        /**
         * Event handler for draw opener
         */
        this.drawOpenButton.addEventListener('click', this.openDrawer.bind(this));
        this.drawBackLayout.addEventListener('click', this.closeDrawer.bind(this));
        this.drawCloseButton.addEventListener('click', this.closeDrawer.bind(this));

        /**
         * Initialize
         */
        this.init();
    }

    /**
     * @func Init
     */
    init() {
        /**
         * Build Filter bar
        */
        this.drawFilterBar(this.DATA);

        /**
        * Init conditions
        */
        this.CONDITIONS.set(this.CONDITION_CHECKBOX, new Map());
        this.CONDITIONS.set(this.CONDITION_RANGE_CHECKBOX, new Map());
        this.CONDITIONS.set(this.CONDITION_RANGE, new Map());
        this.CONDITIONS.set(this.CONDITION_SEARCH, null);
        this.CONDITIONS.set(this.CONDITION_SORT, null);

        /** 
        * Init table
        */
        this.drawTable(this.DATA);
    }

    /**
     * @func NumberRange event handler
     * @param event | Event* 
     */
    numberRange(event) {
        /**
        * Get data-index
        */
        let dataIndexString = event.target.getAttribute('data-index');
        const dataIndex = dataIndexString.split(`${this.SEPERATOR}`);

        /**
        * Get current min value and max value
        */
        const RANGE_MIN_VALUE = Number(event.target.getAttribute('data-min'));
        const RANGE_MAX_VALUE = Number(event.target.getAttribute('data-max'));

        /**
         * Get current block index
         */
        const BLOCK_INDEX = Number(event.target.getAttribute('data-block'));

        /**
        * Action define and checked class add or remove
        */
        let action = this.ACTION_ADD;
        const parentLIelement = event.target.parentElement;
        const parentULelement = parentLIelement.parentElement;
        if (event.target.checked) {
            /**
            * Add `checked` class to the parent UL element and LI element
            */
            parentULelement.classList.add('checked');
            parentLIelement.classList.add('checked');
        } else {
            /**
            * Remove `checked` class from the parent UL element,
            * if there is no checked INPUT element
            */
            if (parentULelement.querySelectorAll('input:checked').length == 0) {
                parentULelement.classList.remove('checked');
            }

            /**
            * Remove `checked` class from the parent LI element
            */
            parentLIelement.classList.remove('checked');

            /**
            * Reassign `remove` to `action`
            */
            action = this.ACTION_REMOVE;
        }

        /**
        * Validate data-index
        */
        if (!dataIndex || dataIndex?.length != 2) return;

        /**
        * Update condition in this.condistions
        */
        this.setCondition({
            type: this.CONDITION_RANGE_CHECKBOX,
            index: dataIndex[0],
            action: action,
            block: BLOCK_INDEX,
            min: RANGE_MIN_VALUE,
            max: RANGE_MAX_VALUE
        });
    }

    /**
    * @func Search event handler
    * @param event | Event*
    */
    search(event) {
        /**
         * Get keyword
         */
        const keyWord = event.target.value;

        /**
         * set condition
         */
        this.setCondition({
            type: this.CONDITION_SEARCH,
            value: keyWord
        });
    }

    /**
    * @func Range event handler
    * @param event | Event*
    */
    range(event) {
        /**
        * Get data-index
        */
        let dataIndexString = event.target.getAttribute('data-index');
        const dataIndex = dataIndexString.split(`${this.SEPERATOR}`);

        /**
        * Get current min value and max value
        */
        const RANGE_MIN_VALUE = Number(document.querySelector(`input.input-range.range-input-min[data-index^="${dataIndex[0]}${this.SEPERATOR}"]`).value);
        const RANGE_MAX_VALUE = Number(document.querySelector(`input.input-range.range-input-max[data-index^="${dataIndex[0]}${this.SEPERATOR}"]`).value);

        /**
        * Update condition in this.condistions
        */
        this.setCondition({
            type: this.CONDITION_RANGE,
            index: dataIndex[0],
            min: RANGE_MIN_VALUE,
            max: RANGE_MAX_VALUE
        });
    }

    /**
    * @func Fitler event handler
    * @param event | Event*
    */
    filter(event) {
        /**
        * Get data-index
        */
        let dataIndexString = event.target.getAttribute('data-index');
        const dataIndex = dataIndexString.split(`${this.SEPERATOR}`);

        /**
        * Action define and checked class add or remove
        */
        let action = this.ACTION_ADD;
        const parentLIelement = event.target.parentElement;
        const parentULelement = parentLIelement.parentElement;
        if (event.target.checked) {
            /**
            * Add `checked` class to the parent UL element and LI element
            */
            parentULelement.classList.add('checked');
            parentLIelement.classList.add('checked');
        } else {
            /**
            * Remove `checked` class from the parent UL element,
            * if there is no checked INPUT element
            */
            if (parentULelement.querySelectorAll('input:checked').length == 0) {
                parentULelement.classList.remove('checked');
            }

            /**
            * Remove `checked` class from the parent LI element
            */
            parentLIelement.classList.remove('checked');

            /**
            * Reassign `remove` to `action`
            */
            action = this.ACTION_REMOVE;
        }

        /**
        * Validate data-index
        */
        if (!dataIndex || dataIndex?.length != 2) return;

        /**
        * Add or Remove condition in this.condistions
        */
        this.setCondition({
            type: this.CONDITION_CHECKBOX,
            action: action,
            index: dataIndex[0],
            value: dataIndex[1]
        });
    }

    /**
    * @func Sort event handler
    * @param event | Event*
    */
    sort(event) {
        const sortValue = event.target.value;
        this.setCondition({
            type: this.CONDITION_SORT,
            value: sortValue
        });
    }

    /**
    * @func SetCondition for filtering
    * @param obj | Object*
    */
    setCondition(obj) {
        switch (obj.type) {

            /**
            * Number Range min and max value
            */
            case this.CONDITION_RANGE_CHECKBOX:
                
                /**
                 * Get origin condition
                 */
                let condition_range_checkbox = this.CONDITIONS.get(this.CONDITION_RANGE_CHECKBOX).get(obj.index);

                /**
                 * If the origin condition is null, init with Map Object
                 */
                condition_range_checkbox = condition_range_checkbox ? condition_range_checkbox : new Map();

                /**
                 * Add or remove by obj.action to `condition_range_checkbox`
                 */
                if (obj.action == this.ACTION_ADD) condition_range_checkbox.set(obj.block, {
                    min: obj.min,
                    max: obj.max
                });
                else condition_range_checkbox.delete(obj.block);

                /**
                 * If `condition_range_checkbox` has values, add update conditions, and if its length is 0, delete condition
                 */
                if (condition_range_checkbox.size === 0) this.CONDITIONS.get(this.CONDITION_RANGE_CHECKBOX).delete(obj.index);
                else this.CONDITIONS.get(this.CONDITION_RANGE_CHECKBOX).set(obj.index, condition_range_checkbox);

                break;

            /**
            * Range min and max value
            */
            case this.CONDITION_RANGE:
                this.CONDITIONS.get(this.CONDITION_RANGE).set(obj.index, {
                    min: obj.min,
                    max: obj.max
                });
                break;

            /**
            * Filter options add/remove
            */
            case this.CONDITION_CHECKBOX:
                /**
                 * Get origin value
                 */
                let condition = this.CONDITIONS.get(this.CONDITION_CHECKBOX).get(obj.index);

                /**
                 * If the origin value is null, init with Set Object
                 */
                condition = condition ? condition : new Set();

                /**
                 * Add or remove byt obj.action to `condition`
                 */
                if (obj.action == this.ACTION_ADD) condition.add(obj.value);
                else condition.delete(obj.value);

                /**
                 * If its size is 0, delete conditions, and if it has values, add to conditions
                 */
                if (condition.size === 0) this.CONDITIONS.get(this.CONDITION_CHECKBOX).delete(obj.index);
                else this.CONDITIONS.get(this.CONDITION_CHECKBOX).set(obj.index, condition);
                break;

            /**
            * Search keyword 
            */
            case this.CONDITION_SEARCH:
                this.CONDITIONS.set(this.CONDITION_SEARCH, obj.value);
                break;

            /**
            * Sort 
            */
            case this.CONDITION_SORT:
                this.CONDITIONS.set(this.CONDITION_SORT, obj.value);
                break;

            default:
                break;
        }

        /**
         * filterByConditions
         */
        this.filterByConditions(obj);
    }

    /**
    * @func filterByConditions
    * @param obj | Object*
    */
    filterByConditions(obj) {

        /**
         * Assign DATA to new variable for filtering and sorting
         */
        let data = this.DATA;

        /**
        * Apply search keyword
        */
        let keyword = this.CONDITIONS.get(this.CONDITION_SEARCH);
        if (keyword != "" && keyword != null)
            data = data.filter(item =>
                item.findIndex((column, ind) => {
                    /**
                     * If the type of column is array, find keyword in array
                     */
                    if (this.HEADER[ind].isArray) return column.value.findIndex(val => val.toUpperCase().indexOf(keyword.toUpperCase()) > -1) > -1;
                    else {
                        /**
                         * If the type of column is number for range filter, add unit to value for searching
                         */
                        if (this.HEADER[ind].unit) column.value += this.HEADER[ind].unit;
                        
                        return column.value.toUpperCase().indexOf(keyword.toUpperCase()) > -1;
                    }
                }) > -1
            );

        /**
         * Init new Map Object for filterable entires counting 
         */
        const filterCountData = new Map();
        /**
         * Assign data to all filterCountData object's values
         */
        this.FILTERS.map(headerIndex => filterCountData.set(headerIndex, data));
        
        /**
        * Apply filter options
        */
        this.CONDITIONS.get(this.CONDITION_CHECKBOX).forEach((value, key) => {
            /**
             * If the type of column is array, use findIndex property of Array object
             */
            if (this.HEADER[key].isArray) {
                data = data.filter(item => item[parseInt(key)].value.findIndex(subItem => value.has(subItem)) > -1);
                /**
                 * Update filterCountData
                 */
                filterCountData.forEach((filterDataValue, filterDataKey) => {
                    /**
                     * Skip if its key and current filtering key is same for counting available entries number on filter bar
                     */
                    if (filterDataKey != key) {
                        const updatedFilterData = filterDataValue.filter(item => item[parseInt(key)].value.findIndex(subItem => value.has(subItem)) > -1);
                        filterCountData.set(filterDataKey, updatedFilterData);
                    }
                })
            }
            else {
                data = data.filter(item => value.has(item[parseInt(key)].value));
                /**
                 * Update filterCountData
                 */
                filterCountData.forEach((filterDataValue, filterDataKey) => {
                    /**
                     * Skip if its key and current filtering key is same for counting available entries number on filter bar
                     */
                    if (filterDataKey != key) {
                        const updatedFilterData = filterDataValue.filter(item => value.has(item[parseInt(key)].value));
                        filterCountData.set(filterDataKey, updatedFilterData);
                    }
                })
            }
        });

        /**
        * Apply Range options
        */
        this.CONDITIONS.get(this.CONDITION_RANGE).forEach((value, key) => {
            data = data.filter(item => {
                const itemValue = Number(item[parseInt(key)].value)
                return value.min <= itemValue && itemValue <= value.max
            });

            /**
             * Update filterCountData
             */
            filterCountData.forEach((filterDataValue, filterDataKey) => {
                /**
                 * Skip if its key and current filtering key is same for counting available entries number on filter bar
                 */
                if (filterDataKey != key) {
                    /**
                     * Filter for range
                     */
                    const updatedFilterData = filterDataValue.filter(item => {
                        const itemValue = Number(item[parseInt(key)].value)
                        return value.min <= itemValue && itemValue <= value.max
                    });
                    /**
                     * Update data
                     */
                    filterCountData.set(filterDataKey, updatedFilterData);
                }
            })
        });

        /**
        * Apply Range Checkbox options
        */
        this.CONDITIONS.get(this.CONDITION_RANGE_CHECKBOX).forEach((value, key) => {
            
            /**
             * Init TempData
             */
            const TempData = [];
            
            /**
             * Filter and push to TempData
             */
            value.forEach((range, blockIndex) => {
                data.map(item => {
                    const itemValue = Number(item[parseInt(key)].value)
                    if (range.min < itemValue && itemValue <= range.max) TempData.push(item);
                });
            });
            
            /**
             * Assign TempData to data
             */
            data = TempData;

            /**
             * Delete TempData
             */
            TempData.slice(TempData.length);
            
            /**
             * filterCountData update
             */
            filterCountData.forEach((filterDataValue, filterDataKey) => {

                /**
                 * If its key and current filtering key is same, skip to display all available entry numbers on filter bar
                 */
                if (filterDataKey != key) {

                    /**
                     * Init filterTempData
                     */
                    const filterTempData = [];
                    
                    /**
                     * Filter and push to filterTempData
                     */
                    value.forEach((range, blockIndex) => {
                        filterDataValue.map(item => {
                            const itemValue = Number(item[parseInt(key)].value)
                            if (range.min < itemValue && itemValue <= range.max) filterTempData.push(item);
                        });
                    });
                    
                    /**
                     * Assign TempData to data
                     */
                    data = filterTempData;

                    /**
                     * Delete TempData
                     */
                    filterTempData.slice(filterTempData.length);

                    filterCountData.set(filterDataKey, filterTempData);
                }
            })
        })

        /**
        * Apply sort
        */
        if (this.CONDITIONS.get(this.CONDITION_SORT)) {

            switch (this.CONDITIONS.get(this.CONDITION_SORT)) {
                /**
                 * TITRE
                 */
                case this.SORT_TITRE_ASC:
                    data.sort((a, b) => a[this.SORTS[this.SORT_TITRE_ASC]].value
                        .localeCompare(b[this.SORTS[this.SORT_TITRE_ASC]].value));
                    break;
                case this.SORT_TITRE_DES:
                    data.sort((a, b) => a[this.SORTS[this.SORT_TITRE_DES]].value
                        .localeCompare(b[this.SORTS[this.SORT_TITRE_DES]].value));
                    data.reverse();
                    break;

                /**
                 * DEPARTEMENT
                 */
                case this.SORT_DEPARTEMENT_ASC:
                    data.sort((a, b) => a[this.SORTS[this.SORT_DEPARTEMENT_ASC]].value
                        .localeCompare(b[this.SORTS[this.SORT_DEPARTEMENT_ASC]].value));
                    break;
                case this.SORT_DEPARTEMENT_DES:
                    data.sort((a, b) => a[this.SORTS[this.SORT_DEPARTEMENT_DES]].value
                        .localeCompare(b[this.SORTS[this.SORT_DEPARTEMENT_DES]].value));
                    data.reverse();
                    break;    

                /**
                 * DIFFICULTE
                 */
                case this.SORT_DIFFICULTE_ASC:
                    data.sort((a, b) => 
                                this.DIFFICULTE_NUMBER_ARRAY[a[this.SORTS[this.SORT_DIFFICULTE_ASC]].value.toUpperCase()] 
                                - this.DIFFICULTE_NUMBER_ARRAY[b[this.SORTS[this.SORT_DIFFICULTE_ASC]].value.toUpperCase()]
                            );
                    break;
                case this.SORT_DIFFICULTE_DES:
                    data.sort((a, b) => 
                                this.DIFFICULTE_NUMBER_ARRAY[b[this.SORTS[this.SORT_DIFFICULTE_DES]].value.toUpperCase()] 
                                - this.DIFFICULTE_NUMBER_ARRAY[a[this.SORTS[this.SORT_DIFFICULTE_DES]].value.toUpperCase()]
                            );
                    break;
                   
                /**
                 * DISTANCE
                 */
                case this.SORT_DISTANCE_ASC:
                    data.sort((a, b) => 
                                a[this.SORTS[this.SORT_DISTANCE_ASC]].value 
                                - b[this.SORTS[this.SORT_DISTANCE_ASC]].value
                            );
                    break;
                case this.SORT_DISTANCE_DES:
                    data.sort((a, b) => 
                                b[this.SORTS[this.SORT_DISTANCE_DES]].value 
                                - a[this.SORTS[this.SORT_DISTANCE_DES]].value
                            );
                    break;

                /**
                 * DUREE
                 */
                case this.SORT_DUREE_ASC:
                    data.sort((a, b) => 
                                a[this.SORTS[this.SORT_DUREE_ASC]].value 
                                - b[this.SORTS[this.SORT_DUREE_ASC]].value
                            );
                    break;
                case this.SORT_DUREE_DES:
                    data.sort((a, b) => 
                                b[this.SORTS[this.SORT_DUREE_DES]].value 
                                - a[this.SORTS[this.SORT_DUREE_DES]].value
                            );
                    break;

                default:
                    /**
                     * Default sort TITLE_ASC sorting
                     */
                    data.sort((a, b) => a[this.SORTS[this.SORT_TITRE_ASC]].value
                        .localeCompare(b[this.SORTS[this.SORT_TITRE_ASC]].value));
                    break;
            }
        } else {
            /**
             * Default sort TITLE_ASC sorting
             */
            data.sort((a, b) => a[this.SORTS[this.SORT_TITRE_ASC]].value.localeCompare(b[this.SORTS[this.SORT_TITRE_ASC]].value));
        }

        /**
         * Update fitler bar
         */
        this.drawFilterBar(filterCountData, obj);

        /**
         * Update table
         */
        this.drawTable(data);
    }

    /**
    * @func DrawFilterBar
    * @param data | Array*
    * @param UPDATED_FILTER_OBJECT | Object, default is null
    */
    drawFilterBar(data, UPDATED_FILTER_OBJECT) {
        /**
        * To optimize run-time re-arrang `data`
        */
        const dataMapped = [];
        if (UPDATED_FILTER_OBJECT) data.forEach((value, key) => {
            /**
             * If UPDATED_FILTER_OBJECT true, map
             */
            value.map(item => {
                item.map((field, ind) => {
                    if (key == ind) {
                        if (!dataMapped[ind]) dataMapped[ind] = [];
                        if (field.value != "") dataMapped[ind].push(field.value);
                    }
                })
            });
        });
        else data.map(item => {
            item.map((field, ind) => {
                if (!dataMapped[ind]) dataMapped[ind] = [];
                if (field.value != "") dataMapped[ind].push(field.value);
            })
        });

        /**
         * Init TEMP_OPTIONS to hide unavailable options if UPDATED_FILTER_OBJECT true
         */
        if (UPDATED_FILTER_OBJECT) this.TEMP_OPTIONS = new Set();

        /**
         * Map FILTERS for trigger updated values with param data
         */
        this.FILTERS.forEach(headerIndex => {

            let item = this.HEADER[headerIndex];

            /**
            * If sort column or range column on range change event, return to skip creating sorting title column in filter bar section
            */
            if (
                item.index == this.SORT_INDEX ||
                (UPDATED_FILTER_OBJECT?.type == this.CONDITION_RANGE && item.index == UPDATED_FILTER_OBJECT?.index)
            ) return;

            /**
            * Data assign to reduce calling `dataMapped` variable
            */
            const DATA_ENTRIES = dataMapped[item.index] ? dataMapped[item.index] : [];

            /**
            * Init config & count variable as a Map object
            */
            const SELECT_OPTIONS_COUNT = new Map();
            const RANGE_CONFIGURATION = new Map();

            /**
            * TYPE CASE
            */
            switch (item.type) {

                case this.TYPE_RANGE_CHECKBOX:
                    /**
                    * Mapping matched values & count number
                    */
                    DATA_ENTRIES?.forEach(key => {
                        /**
                         * Cast to Number
                         */
                        key = Number(key) ? Number(key) : 0;

                        /**
                         * Get blockIndex for valid range area
                         */
                        const blockIndex = Math.min(parseInt(key / item.blockSize) - (key % item.blockSize == 0 ? 1 : 0), item.blocks.length - 1);

                        /**
                         * To avoid containing blank values
                         */
                        if (blockIndex >= 0)
                            SELECT_OPTIONS_COUNT.set(blockIndex, 
                                SELECT_OPTIONS_COUNT.has(blockIndex) 
                                ? SELECT_OPTIONS_COUNT.get(blockIndex) + 1 
                                : 1
                            )
                    });
                    break;

                case this.TYPE_RANGE:
                    /**
                    * Minimium and maximium values for range bar
                    */
                    RANGE_CONFIGURATION.set('min', Math.min(...DATA_ENTRIES, 0));
                    RANGE_CONFIGURATION.set('max', Math.max(...DATA_ENTRIES, 0));
                    RANGE_CONFIGURATION.set('step', item.step);
                    RANGE_CONFIGURATION.set('unit', item.unit);
                    break;

                case this.TYPE_CHECKBOX:
                    /**
                    * Mapping matched values & count number
                    */
                    DATA_ENTRIES?.forEach(key => {
                        if (item.isArray) {
                            key.map(k => SELECT_OPTIONS_COUNT.set(k, SELECT_OPTIONS_COUNT.has(k) ? SELECT_OPTIONS_COUNT.get(k) + 1 : 1));
                        } else {
                            SELECT_OPTIONS_COUNT.set(key, SELECT_OPTIONS_COUNT.has(key) ? SELECT_OPTIONS_COUNT.get(key) + 1 : 1);
                        }
                    });
                    break;
                default:
                    break;
            }

            /**
            * Create or create filter bar
            */
            this.updateOrCreateFilterOption({
                label: item.label,
                type: item.type,
                index: item.index,
                time_formatting: item.time_formatting,
                blockSize: item.blockSize,
                blocks: item.blocks,
                options: SELECT_OPTIONS_COUNT,
                rangeConfig: RANGE_CONFIGURATION,
                created: (UPDATED_FILTER_OBJECT ? true : false),
                filterIndex: UPDATED_FILTER_OBJECT?.index
            });
        });

        /**
         * Hide unavailable filters
         */
        if (UPDATED_FILTER_OBJECT) {

            /**
             * Add `hide-option` class
             */
            this.SELECT_OPTIONS.forEach(value => {
                if (!this.TEMP_OPTIONS.has(value)) 
                    document.querySelector(`LI${UPDATED_FILTER_OBJECT.index ? `:not([data-index^="${UPDATED_FILTER_OBJECT.index}${this.SEPERATOR}"])` : ``}[data-index="${value}"]`)?.classList.add('hide-option');
            })
        }

        /**
         * Remove activated tags all
         */
        this.activatedTagsBox.innerHTML = "";

        /**
         * Create activated tags
         */
        document.querySelectorAll('UL.checked li.filter-option.checked').forEach(item => {
            /**
             * Get label
             */
            const tagLabel = item.querySelector('.checkbox-label').innerHTML.replace(this.REG_EX_LABEL, "");

            /**
             * Create LI element 
             */
            const filterTag = document.createElement('LI');
            filterTag.classList.add('tag');
            filterTag.classList.add('tag--remove');
            filterTag.innerHTML = `<a class="btn btn--small">${tagLabel}</a><svg aria-hidden="true" focusable="false" role="presentation" class="icon icon-close" viewBox="0 0 64 64"><path d="M19 17.61l27.12 27.13m0-27.12L19 44.74"></path></svg>`;
            this.activatedTagsBox.appendChild(filterTag);

            /**
             * Event handler
             */
            filterTag.addEventListener('click', (event) => {
                item.click();
            })
        })
    }

    /**
    * @func UpdateOrCreateFilterOption
    * @param fitler | Object*
    */
    updateOrCreateFilterOption(filter) {

        /**
        * Create Case
        */
        if (!filter.created) {
            /**
            * `filter-option-box` create 
            */
            const filterBox = document.createElement('filter-option-box');
            filterBox.classList.add('filter-opion-box');
            this.filterBox.appendChild(filterBox);

            /**
            * Create LABEL element and add classname
            */
            const filterLabel = document.createElement('LABEL');
            filterLabel.innerHTML = filter.label;
            filterLabel.classList.add('filter-filter-label');
            filterBox.appendChild(filterLabel);

            /**
            * Create UL element and add classname, set `data-row` and `data-type` attributes
            */
            const filterList = document.createElement('UL');
            filterList.classList.add('filter-filters-list');
            filterList.setAttribute('data-row', `${filter.index}`);
            filterList.setAttribute('data-type', `${filter.type}`);
            filterBox.appendChild(filterList);

            /**
            * Case type
            */
            switch (filter.type) {
                case this.TYPE_RANGE_CHECKBOX:
                    /**
                    * Create LI elements and insert children elements ([key, value]) => {}
                    */
                    for (const filterOption of filter.options.entries()) {
                        /**
                        * Create LI element and add `data-index` attribute 
                        */
                        const filterListOne = document.createElement('LI');
                        filterListOne.classList.add('filter-option');
                        filterListOne.setAttribute('data-index', `${filter.index}${this.SEPERATOR}${filterOption[0]}`);
                        filterList.appendChild(filterListOne);

                        /**
                        * Add to manage filter option visibility
                        */
                        this.SELECT_OPTIONS.add(`${filter.index}${this.SEPERATOR}${filterOption[0]}`);

                        /**
                        * Insert checkbox icon - will be updated
                        */
                        const checkboxIcon = document.createElement('SPAN');
                        checkboxIcon.classList.add('filter-checkbox');
                        filterListOne.appendChild(checkboxIcon);

                        /**
                        * Insert checkbox INPUT with name, value, type, `data-index` attributes
                        */
                        const checkBoxInput = document.createElement('INPUT');
                        checkBoxInput.type = 'checkbox';
                        checkBoxInput.name = filter.label;
                        checkBoxInput.value = filterOption[0];
                        checkBoxInput.classList.add('input-select');
                        checkBoxInput.setAttribute('data-index', `${filter.index}${this.SEPERATOR}${filterOption[0]}`);
                        checkBoxInput.setAttribute('data-min', filter.blocks[filterOption[0]].min);
                        checkBoxInput.setAttribute('data-max', filter.blocks[filterOption[0]].max);
                        checkBoxInput.setAttribute('data-block', filterOption[0]);
                        filterListOne.appendChild(checkBoxInput);

                        /**
                        * Define click eventListener 
                        */
                        checkBoxInput.addEventListener('click', this.numberRange.bind(this));

                        /**
                        * Insert checkbox LABEL
                        */
                        const checkboxLabel = document.createElement('SPAN');
                        checkboxLabel.classList.add('checkbox-label');
                        checkboxLabel.innerHTML = filter.blocks[filterOption[0]].label + ` <span class="item-count">(${filterOption[1]})</span>`;
                        filterListOne.appendChild(checkboxLabel);
                    }
                    break;

                case this.TYPE_RANGE:
                    /**
                    * Min, Max, Step, and Unit
                    */
                    const RANGE_MIN = filter.rangeConfig.get('min');
                    const RANGE_MAX = filter.rangeConfig.get('max');
                    const RANGE_STEP = filter.rangeConfig.get('step');
                    const UNIT = filter.rangeConfig.get('unit');

                    /**
                    * Create LI element and add `data-index` attribute 
                    */
                    const rangeLabelList = document.createElement('LI');
                    rangeLabelList.classList.add('filter-option');
                    rangeLabelList.classList.add('range-option-li');
                    rangeLabelList.classList.add('range-option-label-box');
                    rangeLabelList.setAttribute('data-index', `${filter.index}${this.SEPERATOR}label-input-box`);
                    filterList.appendChild(rangeLabelList);

                    /**
                    * Create labels for input range values
                    */
                    const formattingForTimeRange = (number, flag) => {
                        if (!flag) return number;
                        let hours = parseInt(parseInt(number) / 60);
                        let mins = parseInt(parseInt(number) % 60);
                        return `${hours.toString().padStart(2, 0)}:${mins.toString().padStart(2, 0)}`;
                    }

                    const rangeMinLabel = document.createElement('SPAN');
                    rangeMinLabel.classList.add('filter-range-label-min');
                    rangeMinLabel.innerHTML = `${formattingForTimeRange(RANGE_MIN, filter.time_formatting)}${UNIT}`;
                    rangeLabelList.appendChild(rangeMinLabel);

                    const rangeMaxLabel = document.createElement('SPAN');
                    rangeMaxLabel.classList.add('filter-range-label-max');
                    rangeMaxLabel.innerHTML = `${formattingForTimeRange(RANGE_MAX, filter.time_formatting)}${UNIT}`;
                    rangeLabelList.appendChild(rangeMaxLabel);

                    /**
                    * Create LI element and add `data-index` attribute 
                    */
                    const rangeInputsList = document.createElement('LI');
                    rangeInputsList.classList.add('filter-option');
                    rangeInputsList.classList.add('range-option-li');
                    rangeInputsList.setAttribute('data-index', `${filter.index}${this.SEPERATOR}range-input-box`);
                    filterList.appendChild(rangeInputsList);

                    /**
                    * Insert range INPUT for minimium & maximium values
                    */
                    const minRangeInput = document.createElement('INPUT');
                    minRangeInput.type = 'range';
                    minRangeInput.min = RANGE_MIN;
                    minRangeInput.max = RANGE_MAX;
                    minRangeInput.step = RANGE_STEP;
                    minRangeInput.value = RANGE_MIN;
                    minRangeInput.classList.add('range-input-min');
                    minRangeInput.classList.add('input-range');
                    minRangeInput.setAttribute('data-index', `${filter.index}${this.SEPERATOR}${RANGE_MIN}`);
                    rangeInputsList.appendChild(minRangeInput);
                    minRangeInput.addEventListener('change', this.range.bind(this));


                    const maxRangeInput = document.createElement('INPUT');
                    maxRangeInput.type = 'range';
                    maxRangeInput.min = RANGE_MIN;
                    maxRangeInput.max = RANGE_MAX;
                    maxRangeInput.step = RANGE_STEP;
                    maxRangeInput.value = RANGE_MAX;
                    maxRangeInput.classList.add('range-input-max');
                    maxRangeInput.classList.add('input-range');
                    maxRangeInput.setAttribute('data-index', `${filter.index}${this.SEPERATOR}${RANGE_MAX}`);
                    rangeInputsList.appendChild(maxRangeInput);
                    maxRangeInput.addEventListener('change', this.range.bind(this));

                    const rangeBetweenFill = document.createElement('DIV');
                    rangeBetweenFill.classList.add('range-between-fill');
                    rangeInputsList.appendChild(rangeBetweenFill);

                    const RangeBetweenFillUpdate = () => {
                        const INPUT_MAX_VALUE = Number(maxRangeInput.value);
                        const INPUT_MIN_VALUE = Number(minRangeInput.value);
                        const INPUT_RANGE_MAX = Number(minRangeInput.max);
                        const INPUT_RANGE_MIN = Number(minRangeInput.min);
                        const TOTAL_RANGE = INPUT_RANGE_MAX - INPUT_RANGE_MIN;
                        const CURRENT_RANGE = INPUT_MAX_VALUE - INPUT_MIN_VALUE;
                        rangeBetweenFill.style.width = `${CURRENT_RANGE / TOTAL_RANGE * 100}%`;
                        rangeBetweenFill.style.left = `${(INPUT_MIN_VALUE - INPUT_RANGE_MIN) / TOTAL_RANGE * 100}%`;
                    }

                    //event handlers
                    const betweenRangeThumbBox = document.querySelector('input.range-input-max.input-range::after');
                    minRangeInput.addEventListener('input', event => {
                        if (Number(event.target.value) > (Number(maxRangeInput.value) - Number(RANGE_STEP))) {
                            event.target.value = Number(maxRangeInput.value) - Number(RANGE_STEP);
                        }
                        RangeBetweenFillUpdate();
                        rangeMinLabel.innerHTML = `${formattingForTimeRange(event.target.value, filter.time_formatting)}${UNIT}`;
                    });
                    maxRangeInput.addEventListener('input', event => {
                        if (Number(event.target.value) < (Number(minRangeInput.value) + Number(RANGE_STEP))) {
                            event.target.value = Number(minRangeInput.value) + Number(RANGE_STEP);
                        }
                        RangeBetweenFillUpdate();
                        rangeMaxLabel.innerHTML = `${formattingForTimeRange(event.target.value, filter.time_formatting)}${UNIT}`;
                    });

                    break;
                case this.TYPE_CHECKBOX:
                    /**
                    * Create LI elements and insert children elements ([key, value]) => {}
                    */
                    for (const filterOption of filter.options.entries()) {
                        /**
                        * Create LI element and add `data-index` attribute 
                        */
                        const filterListOne = document.createElement('LI');
                        filterListOne.classList.add('filter-option');
                        filterListOne.setAttribute('data-index', `${filter.index}${this.SEPERATOR}${filterOption[0]}`);
                        filterList.appendChild(filterListOne);

                        /**
                        * Add to manage filter option visibility
                        */
                        this.SELECT_OPTIONS.add(`${filter.index}${this.SEPERATOR}${filterOption[0]}`);

                        /**
                        * Insert checkbox icon - will be updated
                        */
                        const checkboxIcon = document.createElement('SPAN');
                        checkboxIcon.classList.add('filter-checkbox');
                        filterListOne.appendChild(checkboxIcon);

                        /**
                        * Insert checkbox INPUT with name, value, type, `data-index` attributes
                        */
                        const checkBoxInput = document.createElement('INPUT');
                        checkBoxInput.type = 'checkbox';
                        checkBoxInput.name = filter.label;
                        checkBoxInput.value = filterOption[0];
                        checkBoxInput.classList.add('input-select');
                        checkBoxInput.setAttribute('data-index', `${filter.index}${this.SEPERATOR}${filterOption[0]}`);
                        filterListOne.appendChild(checkBoxInput);

                        /**
                        * Define click eventListener 
                        */
                        checkBoxInput.addEventListener('click', this.filter.bind(this));

                        /**
                        * Insert checkbox LABEL
                        */
                        const checkboxLabel = document.createElement('SPAN');
                        checkboxLabel.classList.add('checkbox-label');
                        checkboxLabel.innerHTML = filterOption[0] + ` <span class="item-count">(${filterOption[1]})</span>`;
                        filterListOne.appendChild(checkboxLabel);
                    }
                    break;
                default:
                    break;
            }
        }

        /**
        * Update Case
        */
        else {
            /**
            * Remove available-option class remove from all elements that has this class
            */
            document.querySelectorAll('.available-option').forEach(item => item.classList.remove('available-option'));

            switch (filter.type) {
                case this.TYPE_RANGE_CHECKBOX:
                    /**
                    * Update count of matched entries @func ([key, value]) => {}
                    */
                    for (const filterOption of filter.options.entries()) {
                        /**
                        * Update count label element and add `data-index` attribute
                        */
                        const countOfOptionMatchedEntries = document.querySelector(`li[data-index="${filter.index}${this.SEPERATOR}${filterOption[0]}"] span.item-count`);
                        countOfOptionMatchedEntries.innerHTML = `(${filterOption[1]})`;

                        /**
                         * Remove `hide-option` class
                         */
                        document.querySelector(`li[data-index="${filter.index}${this.SEPERATOR}${filterOption[0]}"]`).classList.remove('hide-option');

                        /**
                        * Add `available-option` class to prevent hidding available options
                        */
                        this.TEMP_OPTIONS.add(`${filter.index}${this.SEPERATOR}${filterOption[0]}`);
                    }
                    break;
                case this.TYPE_RANGE:
                    /**
                    * Min, Max, Step, and Unit
                    */
                    const RANGE_MIN = filter.rangeConfig.get('min');
                    const RANGE_MAX = filter.rangeConfig.get('max');
                    const UNIT = filter.rangeConfig.get('unit');

                    /**
                    * Update labels for input range values
                    */
                    const formattingForTimeRange = (number, flag) => {
                        if (!flag) return number;
                        let hours = parseInt(number / 60);
                        let mins = parseInt(number % 60);
                        return `${hours.toString().padStart(2, 0)}:${mins.toString().padStart(2, 0)}`;
                    }

                    const rangeMinLabel = document.querySelector(`LI[data-index="${filter.index}${this.SEPERATOR}label-input-box"] SPAN.filter-range-label-min`);
                    rangeMinLabel.innerHTML = `${formattingForTimeRange(RANGE_MIN, filter.time_formatting)}${UNIT}`;

                    const rangeMaxLabel = document.querySelector(`LI[data-index="${filter.index}${this.SEPERATOR}label-input-box"] SPAN.filter-range-label-max`);
                    rangeMaxLabel.innerHTML = `${formattingForTimeRange(RANGE_MAX, filter.time_formatting)}${UNIT}`;

                    /**
                    * Update range INPUT for minimium & maximium values
                    */
                    const minRangeInput = document.querySelector(`LI[data-index="${filter.index}${this.SEPERATOR}range-input-box"] INPUT.range-input-min`);
                    minRangeInput.min = RANGE_MIN;
                    minRangeInput.max = RANGE_MAX;
                    minRangeInput.value = RANGE_MIN;

                    const maxRangeInput = document.querySelector(`LI[data-index="${filter.index}${this.SEPERATOR}range-input-box"] INPUT.range-input-max`);
                    maxRangeInput.min = RANGE_MIN;
                    maxRangeInput.max = RANGE_MAX;
                    maxRangeInput.value = RANGE_MAX;

                    const rangeBetweenFill = document.querySelector(`LI[data-index="${filter.index}${this.SEPERATOR}range-input-box"] .range-between-fill`);
                    rangeBetweenFill.style.width = `100%`;
                    rangeBetweenFill.style.left = `0`;

                    break;
                case this.TYPE_CHECKBOX:
                    /**
                    * Update count of matched entries @func ([key, value]) => {}
                    */
                    for (const filterOption of filter.options.entries()) {
                        /**
                        * Update count label element and add `data-index` attribute
                        */
                        const countOfOptionMatchedEntries = document.querySelector(`li[data-index="${filter.index}${this.SEPERATOR}${filterOption[0]}"] span.item-count`);
                        
                        /**
                         * Remove `hide-option` class
                         */
                        document.querySelector(`li[data-index="${filter.index}${this.SEPERATOR}${filterOption[0]}"]`).classList.remove('hide-option');

                        if (countOfOptionMatchedEntries) {
                            countOfOptionMatchedEntries.innerHTML = `(${filterOption[1]})`;
                            /**
                             * Add `data-index` attribute to TEMP_OPTIONS
                            */
                            this.TEMP_OPTIONS.add(`${filter.index}${this.SEPERATOR}${filterOption[0]}`);
                        }
                    }
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * @func NextPage in pagination
     */
    nextPage() {
        /**
         * Increament CURRENT_PAGE_INDEX
         */
        this.CURRENT_PAGE_INDEX = Math.min(this.CURRENT_PAGE_INDEX + 1, this.PAGE_TOTAL);

        /**
         * Update table
         */
        this.drawTable(this.TEMP_DATA, this.CURRENT_PAGE_INDEX);
    }

    /**
     * @func PrevPage in pagination
     */
    prevPage() {
        this.CURRENT_PAGE_INDEX = Math.max(this.CURRENT_PAGE_INDEX - 1, 0);
        this.drawTable(this.TEMP_DATA, this.CURRENT_PAGE_INDEX);
    }

    /**
     * @func Goto page in pagination
     * @param pageIndex | INT*
     */
    gotoPage(pageIndex) {
        /**
         * Assign pageIndex to CURRENT_PAGE_INDEX
         */
        this.CURRENT_PAGE_INDEX = Number(pageIndex);
        
        /**
         * Update drawTable
         */
        this.drawTable(this.TEMP_DATA, this.CURRENT_PAGE_INDEX);
    }

    /**
     * @func BuildPaginationButtons
     */
    buildPaginationButtons() {

        /**
         * Remove origin pagination buttons
         */
        this.paginationButtonBox.querySelector('.pagination')?.remove();

        if (this.PAGE_TOTAL > 1) {
            /**
             * Create `pagination` div
             */
            const pagination = document.createElement('DIV');
            pagination.classList.add('pagination');
            this.paginationButtonBox.appendChild(pagination);

            /**
             * Add `Prev` button
             */
            if (this.CURRENT_PAGE_INDEX > 0) {
                const prevButtonBox = document.createElement('SPAN');
                prevButtonBox.classList.add('prev');
                pagination.appendChild(prevButtonBox);

                const prevButton = document.createElement('A');
                prevButton.title = "Previous";
                prevButton.innerHTML = this.PREV_BUTTON_ICON;
                prevButtonBox.appendChild(prevButton);

                prevButtonBox.addEventListener('click', this.prevPage.bind(this));
            }

            /**
             * Add first button
             */
            const firstButton = document.createElement('SPAN');
            firstButton.classList.add('page');
            if (this.CURRENT_PAGE_INDEX == 0) {
                firstButton.classList.add('current');
                firstButton.innerHTML = 1;
            } else {
                const buttonContent = document.createElement('A');
                buttonContent.innerHTML = 1;
                firstButton.appendChild(buttonContent);
            }
            firstButton.setAttribute('data-pagination', 0);
            pagination.appendChild(firstButton);
            
            firstButton.addEventListener('click', () => {
                this.gotoPage(0);
            });

            /**
             * Add `...` 
             */
            if (this.CURRENT_PAGE_INDEX > 3) {
                const firstDots = document.createElement('SPAN');
                firstDots.classList.add('page');
                firstDots.innerHTML = this.DOTS_CONTENT;
                pagination.appendChild(firstDots);
            }

            /** 
             * Add 5 buttons of around current button if avilable  
             */
            for (let index = Math.max(1, this.CURRENT_PAGE_INDEX - 2); index <= Math.min(this.PAGE_TOTAL - 2, this.CURRENT_PAGE_INDEX + 2); index++) {
                const paginationButton = document.createElement('SPAN');
                paginationButton.classList.add('page');
                if (this.CURRENT_PAGE_INDEX == index) {
                    paginationButton.innerHTML = index + 1;
                    paginationButton.classList.add('current');
                } else {
                    const buttonContent = document.createElement('A');
                    buttonContent.innerHTML = index + 1;
                    paginationButton.appendChild(buttonContent);
                }
                paginationButton.setAttribute('data-pagination', index);
                pagination.appendChild(paginationButton);
                
                paginationButton.addEventListener('click', () => {
                    this.gotoPage(index);
                });
            }

            /**
             * Add `...` 
             */
            if (this.CURRENT_PAGE_INDEX < this.PAGE_TOTAL - 3) {
                const lastDots = document.createElement('SPAN');
                lastDots.classList.add('page');
                lastDots.innerHTML = this.DOTS_CONTENT;
                pagination.appendChild(lastDots);
            }

            /**
             * Add last button
             */
            const lastButton = document.createElement('SPAN');
            lastButton.classList.add('page');
            if (this.CURRENT_PAGE_INDEX == this.PAGE_TOTAL - 1) {
                lastButton.classList.add('current');
                lastButton.innerHTML = this.PAGE_TOTAL;
            } else {
                const buttonContent = document.createElement('A');
                buttonContent.innerHTML = this.PAGE_TOTAL;
                lastButton.appendChild(buttonContent);
            }
            
            lastButton.setAttribute('data-pagination', this.PAGE_TOTAL - 1);
            pagination.appendChild(lastButton);
            
            lastButton.addEventListener('click', () => {
                this.gotoPage(this.PAGE_TOTAL - 1);
            });

            /**
             * Add `next` button
             */
            if (this.CURRENT_PAGE_INDEX < this.PAGE_TOTAL) {
                const nextButtonBox = document.createElement('SPAN');
                nextButtonBox.classList.add('next');
                pagination.appendChild(nextButtonBox);

                const nextButton = document.createElement('A');
                nextButton.title = "next";
                nextButton.innerHTML = this.NEXT_BUTTON_ICON;
                nextButtonBox.appendChild(nextButton);

                nextButtonBox.addEventListener('click', this.nextPage.bind(this));
            }
        }
    }

    /**
    * @func DrawTable
    * @param data | Array*
    * @param CURRENT_PAGE_INDEX | INT
    */
    drawTable(data, CURRENT_PAGE_INDEX) {
        /**
        * Delete origin TBODY and create new TBODY
        */
        const tbody = document.createElement('TBODY');
        this.tbody.remove();
        this.table.appendChild(tbody);
        this.tbody = tbody;

        /**
         * Assign data to `TEMP_DATA` for pagination
         */
        this.TEMP_DATA = data;

        /**
        * Update total count number
        */
        this.totalCount.innerHTML = data.length;

        if (!CURRENT_PAGE_INDEX) {
            /**
             * Reassign `PAGE_TOTAL`
             */
            this.PAGE_TOTAL = parseInt(data.length / this.ROWS_PER_PAGINATION) + (data.length % this.ROWS_PER_PAGINATION == 0 ? 0 : 1);
            this.CURRENT_PAGE_INDEX = 0;
        }
        
        /**
         * Slice for pagination
         */
        data = data.slice(this.CURRENT_PAGE_INDEX * this.ROWS_PER_PAGINATION, this.CURRENT_PAGE_INDEX * this.ROWS_PER_PAGINATION + this.ROWS_PER_PAGINATION);

        /**
         * Build pagination buttons
         */
        this.buildPaginationButtons();

        /**
        * Create TR elements
        */
        data.map(item => {
            const row = document.createElement('TR');
            tbody.appendChild(row);

            /**
            * Create TD elements
            */
            item.map((column, index) => {
                /**
                 * If hidden column skip creating
                 */
                if (!this.HEADER[index].visible) return;

                /**
                 * TD element create
                 */
                const col = document.createElement('TD');

                /**
                 * HTML insert
                 */
                col.innerHTML = column.html;
                
                /**
                 * Truncate string
                 */
                if (this.HEADER[index].maxLength) {

                    /**
                     * Text trigger
                     */
                    let innerText = column.html.replace(this.REG_EX, '');
                    
                    /**
                     * If length of text is long than maxLength, truncate
                     */
                    if (innerText.length > this.HEADER[index].maxLength) {
                    
                        /**
                         * Replace with `...` last 3 characters
                         */
                        let newInnerText = innerText.slice(0, (this.HEADER[index].maxLength - 3)) + "...";
                        col.innerHTML = column.html.replace(innerText, newInnerText);

                        /**
                         * Set `data-title` for tooltip component
                         */
                        col.setAttribute('data-title', column.value);                    
                    }
                }

                /**
                 * Append to row element
                 */
                row.appendChild(col);
            })
        })

    }

    /**
     * @func OpenDrawer
     */
    openDrawer() {
        this.classList.add('open');
    }
    
    /**
     * @func CloseDrawer
     */
    closeDrawer() {
        this.classList.remove('open');
    }
}

customElements.define('metaobject-table', MetaobjectTable);

/**
 * @class FilterOptionBox custom element for filter bar
*/
class filterOptionBox extends HTMLElement {
    constructor() {
        super()

        this.label = this.querySelector('label.filter-filter-label');
        this.optionList = this.querySelector('ul.filter-filters-list');
        this.label.addEventListener('click', this.toggleUL.bind(this));

        /**
        * Event handler mapping
        */
        this.optionList.querySelectorAll('li.filter-option').forEach(item => {
            item.addEventListener('click', this.toggleLI.bind(this))
        })
    }

    /**
    * @func ToggleUL 
    */
    toggleUL(event) {
        if (this.classList.contains('open')) this.classList.remove('open');
        else this.classList.add('open');
    }

    /**
    * @func ToggleLI
    * @param event | Event*
    */
    toggleLI(event) {
        if (event.target.tagName == 'LI') event.target.querySelector('input[type="checkbox"]')?.click();
    }
}

customElements.define('filter-option-box', filterOptionBox);